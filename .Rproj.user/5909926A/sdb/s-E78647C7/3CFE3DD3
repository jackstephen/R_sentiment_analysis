{
    "contents" : "#######################################################\n#2 解析词林\n# 2.1 编码，符号，词提取，保存为codes, symbols, hwords\n# 2.2 编码各层最大值计算 Ml1 ,Ml2, Ml3, Ml4, Ml5\n# 2.3 拆分词串为单独各词，存入 words <- c()\n# 2.4 数据存list(列表) dict\n#Author:stephen\n#Date:2015/7/17\n#Update: \n#\n#\n#\n######################################\n\npaseWord <- function(words){\n  #取编码，符号，词串\n  codes <- apply(words,2,FUN=function(x) substr(x,1,7))\n # codes <- lapply(codes.m,clevel)\n  symbols <- as.vector(apply(words,2,FUN=function(x) substr(x,8,8)))\n  hwords <- apply(words,2,FUN=function(x) substr(x,10,nchar(x)))\n  #把词串分拆为list,每个list元素就一个vector\n  words <- strsplit(hwords,\" \")  \n  return(list(codes=codes,symbols = symbols,words=words))\n}\n\n\n#################\n#取对应词编码\n######################\ngetCode <- function(w){\n  wMatch <- lapply(dictList$words, FUN = function(x) return(x %in% w) )\n  match.num <- which(unlist(lapply(wMatch, any)))\n  code <- dictList$codes[match.num]\n  symbol <- dictList$symbols[match.num]\n  if(length(code)==0) return(NULL)\n  return(list(code=code,symbol=symbol))\n}\n\n#################\n#计算两词相似度\n#4 计算词相似度\n# 4.1 比较分叉层，确定各层系数c(0.1,0.65,0.8,0.9,0.96,1,0.5),\n#     如果符号为’@’，相似度为0\n#     其它如果在同一叶子节点符号为“=”，系数为1,符号为'#'，系数为0.5\n#     其它相应层分叉对应相应系数：c(0.1,0.65,0.8,0.9,0.96,1,0.5)\n# 4.2 计算相似度并，并返回两词相似度最大值\n######################\n#wd1 <- world1\n#wd2 <- world2\ncalSim <- function(wd1,wd2){\n  code1 <- wd1$code\n  code2 <- wd2$code\n  symbol1 <- wd1$symbol\n  symbol2 <- wd2$symbol\n  coe <- c(0.1,0.65,0.8,0.9,0.96)\n  #编码分割格式化\n  c1.fm <- clevel(code1)\n  c2.fm <- clevel(code2)\n  #取分叉层\n  level.nums <- which(!(c1.fm==c2.fm))\n  #如果在同一层，置层数为6,否取每日一个分叉点\n  level.num <- ifelse(length(level.nums)==0,6,level.nums[1])\n  #相似度计算\n  #初始化符号系数\n  \n  if(all(symbol1=='=',symbol2=='=')){\n    w_simbol <- 1\n  }else {\n    w_simbol <- ifelse(any(symbol1=='#',symbol2=='#'),0.5,0.0)\n  }\n  #如果存在一个符号是'@',直接返回0\n  if(any(symbol1=='@',symbol2=='@')){\n    #print('符号为@,直接返回0.0')\n    return(0.0)\n  }\n  #如果在第一层就分叉，直接返回0.1\n  if(level.num == 1){\n    #print('第一层分叉，返回0.1')\n    return(0.1)\n  }\n  #如果在同一层，根据根据符号不同返回不同'=':1,'#':0.5\n  if(level.num==6){\n    if(symbol1=='=') return(1.0)\n    if(symbol1=='#') return(0.5)\n  }\n  #初始系数\n  e = coe[level.num]\n  #取当层总数\n  n <-getTotal(code1,level.num) \n  #两编码距离（同一层）\n  #如果3，5层，将编码转换成数据相减，如果是2、4层用ascii码来比较\n  k=0\n  if(level.num %% 2 == 1){\n    k <- abs(as.numeric(c1.fm[level.num])-as.numeric(c2.fm[level.num]))\n  }else{\n    k <- abs(as.numeric(charToRaw(c1.fm[level.num]))-as.numeric(charToRaw(c2.fm[level.num])))\n  }\n  sim <- w_simbol*e*cos(n*(pi/180))*((n-k+1)/n) \n  return(sim)\n}\n\n################\n#拆分编码并合并成向量\n###############\nclevel <- function(c){\n  return(c(substr(c,1,1),substr(c,2,2),substr(c,3,4),substr(c,5,5),substr(c,6,7)))\n}\n\n################\n#取当层总数\n###############\n#wd <- 'Aa01B01'\n#lev <- 2\ngetTotal <- function(wd,lev){\n  #如果lev是1，返回 0\n  if(lev == 1) return(0)\n  cur.level <- lev\n  pre.level <- lev-1\n  if(lev >= 3){\n    cur.level <- ifelse(lev > 4,lev+2,lev+1)\n    pre.level <- ifelse(lev >= 4,lev,pre.level)   #修改为大于等于4\n  }\n  #pre.level <- ifelse(cur.level %% 2 == 1,cur.level-2,cur.level-1)\n  mat <- dictList$codes[substr(dictList$codes,1,pre.level)==substr(wd,1,pre.level)]\n  mat.kw <- substr(mat,pre.level+1,cur.level)\n  k <- 0\n  if(lev %% 2 == 1){\n    k <- abs(as.numeric(max(mat.kw))-as.numeric(min(mat.kw)))\n  }else{\n    k <- abs(as.numeric(charToRaw(max(mat.kw)))-as.numeric(charToRaw(min(mat.kw))))\n  }\n  return(k+1)\n}\n\n#############################\n#将有多个编码返回list进行转换\n#list(list(code='001',sybole='='),list(code='001',sybole='='))\n#Modified by stephen at 2015/7/31 增加未发现语处理\n#############################\npaseList <- function(worlds){\n  if(is.null(worlds)) return(worlds)\n  len <- length(worlds$code)\n  wl <- list()\n  if(len==1) wl[[1]]<-worlds\n  for(i in 1:len){\n    wl[[i]] <- list(code=worlds$code[i],symbol=worlds$symbol[i])\n  }\n  return(wl)\n}\n\n\n",
    "created" : 1440135910931.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3821009738",
    "id" : "3CFE3DD3",
    "lastKnownWriteTime" : 1440135559,
    "path" : "D:/GitHub/R_sentiment_analysis/paseWords.R",
    "project_path" : "paseWords.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}